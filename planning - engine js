// Moteur de calcul des cycles de planning (A, B, C, D, E)
class PlanningEngine {
    constructor(db) {
        this.db = db;
        this.DATE_AFFECTATION_BASE = "2025-11-01";
        this.JOURS_FRANCAIS = {
            'Mon': 'Lun', 'Tue': 'Mar', 'Wed': 'Mer', 'Thu': 'Jeu',
            'Fri': 'Ven', 'Sat': 'Sam', 'Sun': 'Dim'
        };
    }

    // Cycle standard 8 jours (1, 1, 2, 2, 3, 3, R, R)
    _cycleStandard8Jours(jourCycle) {
        const cycle = ['1', '1', '2', '2', '3', '3', 'R', 'R'];
        return cycle[jourCycle % 8];
    }

    // Décalage par groupe
    _getDecalageStandard(groupe) {
        const decalages = {
            'A': 0,
            'B': 2,
            'C': 4,
            'D': 6
        };
        return decalages[groupe] || 0;
    }

    // Cycle spécial pour groupe E (5/7 avec shifts 1 et 2 seulement)
    async _cycleGroupeE(date, codeAgent) {
        const dateObj = new Date(date);
        const jourSemaine = dateObj.getDay(); // 0=dimanche, 6=samedi
        
        // Weekend = repos
        if (jourSemaine === 0 || jourSemaine === 6) {
            return 'R';
        }
        
        // Obtenir tous les agents du groupe E
        const agentsE = await this.db.obtenirAgentsParGroupe('E');
        const agentsCodes = agentsE.map(a => a.code);
        
        const indexAgent = agentsCodes.indexOf(codeAgent);
        if (indexAgent === -1) {
            return 'R';
        }
        
        // Numéro de semaine dans l'année
        const dateDebutAnnee = new Date(dateObj.getFullYear(), 0, 1);
        const joursEcoules = Math.floor((dateObj - dateDebutAnnee) / (1000 * 60 * 60 * 24));
        const semaine = Math.ceil((joursEcoules + dateDebutAnnee.getDay() + 1) / 7);
        
        const jourPair = (dateObj.getDay() % 2 === 1); // Lundi=1 (impair)
        
        // Logique spécifique pour groupe E
        if (indexAgent === 0) { // Premier agent
            if (semaine % 2 === 1) { // Semaine impaire
                return jourPair ? '1' : '2';
            } else { // Semaine paire
                return jourPair ? '2' : '1';
            }
        } else if (indexAgent === 1) { // Deuxième agent
            if (semaine % 2 === 1) {
                return jourPair ? '2' : '1';
            } else {
                return jourPair ? '1' : '2';
            }
        } else { // Autres agents
            return (indexAgent + semaine) % 2 === 0 ? '1' : '2';
        }
    }

    // Calcul du shift théorique
    async calculerShiftTheorique(codeAgent, date) {
        const agent = await this.db.obtenirAgent(codeAgent);
        if (!agent || agent.statut !== 'actif') {
            return '-';
        }
        
        // Vérifier si l'agent est sorti
        if (agent.date_sortie && new Date(date) >= new Date(agent.date_sortie)) {
            return '-';
        }
        
        // Vérifier si la date est avant l'entrée
        const dateEntree = agent.date_entree || this.DATE_AFFECTATION_BASE;
        if (new Date(date) < new Date(dateEntree)) {
            return '-';
        }
        
        // Calculer le nombre de jours depuis l'entrée
        const dateEntreeObj = new Date(dateEntree);
        const dateObj = new Date(date);
        const joursEcoules = Math.floor((dateObj - dateEntreeObj) / (1000 * 60 * 60 * 24));
        
        // Appliquer le cycle selon le groupe
        if (agent.groupe === 'E') {
            return await this._cycleGroupeE(date, codeAgent);
        } else if (['A', 'B', 'C', 'D'].includes(agent.groupe)) {
            const decalage = this._getDecalageStandard(agent.groupe);
            const jourCycle = joursEcoules + decalage;
            return this._cycleStandard8Jours(jourCycle);
        }
        
        return 'R';
    }

    // Générer le planning théorique pour un mois
    async genererPlanningTheorique(codeAgent, mois, annee) {
        const joursDansMois = new Date(annee, mois, 0).getDate();
        const planning = [];
        
        for (let jour = 1; jour <= joursDansMois; jour++) {
            const date = `${annee}-${mois.toString().padStart(2, '0')}-${jour.toString().padStart(2, '0')}`;
            const shift = await this.calculerShiftTheorique(codeAgent, date);
            
            const dateObj = new Date(date);
            const jourSemaine = dateObj.getDay();
            const nomJour = this.JOURS_FRANCAIS[dateObj.toLocaleDateString('en-US', { weekday: 'short' })];
            
            // Vérifier si c'est un jour férié
            const estFerie = await this.db.estJourFerie(date);
            
            planning.push({
                jour: jour,
                date: date,
                jour_semaine: nomJour,
                shift: shift,
                ferie: estFerie,
                est_dimanche: jourSemaine === 0
            });
        }
        
        return planning;
    }

    // Générer planning pour un groupe
    async genererPlanningGroupe(groupe, mois, annee) {
        const agents = await this.db.obtenirAgentsParGroupe(groupe);
        const planningAgents = [];
        
        for (const agent of agents) {
            if (agent.statut === 'actif') {
                const planning = await this.genererPlanningTheorique(agent.code, mois, annee);
                planningAgents.push({
                    agent,
                    planning
                });
                
                // Enregistrer les shifts théoriques
                for (const jour of planning) {
                    await this.db.enregistrerShift(agent.code, jour.date, jour.shift, 'THEORIQUE');
                }
            }
        }
        
        return planningAgents;
    }

    // Calculer les statistiques d'un agent
    async calculerStatsAgent(codeAgent, mois, annee) {
        const planning = await this.genererPlanningTheorique(codeAgent, mois, annee);
        
        const stats = {
            '1': 0, '2': 0, '3': 0, 'R': 0, 'C': 0, 'M': 0, 'A': 0, '-': 0
        };
        
        let joursFeriesTravailles = 0;
        let totalJours = 0;
        
        for (const jour of planning) {
            const shift = jour.shift;
            if (stats[shift] !== undefined) {
                stats[shift]++;
                
                if (['1', '2', '3'].includes(shift)) {
                    totalJours++;
                    if (jour.ferie) {
                        joursFeriesTravailles++;
                    }
                }
            }
        }
        
        const agent = await this.db.obtenirAgent(codeAgent);
        let totalOperationnels = totalJours;
        
        // Pour les groupes A-D, ajouter les jours fériés travaillés au total
        if (agent && agent.groupe !== 'E') {
            totalOperationnels += joursFeriesTravailles;
        }
        
        return {
            stats,
            joursFeriesTravailles,
            totalJoursTravailles: totalJours,
            totalOperationnels,
            totalJours: planning.length
        };
    }

    // Calculer les jours travaillés par groupe
    async calculerJoursTravaillesGroupe(groupe, mois, annee) {
        const planningGroupe = await this.genererPlanningGroupe(groupe, mois, annee);
        let totalGroupe = 0;
        
        for (const item of planningGroupe) {
            const stats = await this.calculerStatsAgent(item.agent.code, mois, annee);
            totalGroupe += stats.totalOperationnels;
        }
        
        return totalGroupe;
    }

    // Vérifier si un shift peut être modifié (pas de congé, maladie, etc.)
    async peutModifierShift(codeAgent, date) {
        const planning = await this.db.get('planning', [codeAgent, date]);
        if (!planning) {
            return true;
        }
        
        const shift = planning.shift.toUpperCase();
        // Ne peut pas modifier les congés, maladies, absences enregistrés
        return !['C', 'M', 'A'].includes(shift);
    }

    // Obtenir le nombre de jours entre deux dates
    getJoursEntreDates(dateDebut, dateFin) {
        const debut = new Date(dateDebut);
        const fin = new Date(dateFin);
        const difference = fin.getTime() - debut.getTime();
        return Math.ceil(difference / (1000 * 3600 * 24)) + 1;
    }

    // Calculer la période de congé avec gestion des dimanches
    async calculerCongesAvecDimanches(codeAgent, dateDebut, dateFin) {
        const joursConges = [];
        const dateDebutObj = new Date(dateDebut);
        const dateFinObj = new Date(dateFin);
        let currentDate = new Date(dateDebutObj);
        
        while (currentDate <= dateFinObj) {
            const dateStr = currentDate.toISOString().split('T')[0];
            const jourSemaine = currentDate.getDay();
            
            if (jourSemaine === 0) { // Dimanche
                joursConges.push({
                    date: dateStr,
                    shift: 'R',
                    type: 'CONGE_DIMANCHE'
                });
            } else {
                joursConges.push({
                    date: dateStr,
                    shift: 'C',
                    type: 'CONGE_PERIODE'
                });
            }
            
            currentDate.setDate(currentDate.getDate() + 1);
        }
        
        return joursConges;
    }
}

// Export global
window.PlanningEngine = PlanningEngine;
